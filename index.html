<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Video — Auto Connect</title>
  <style>
    :root {
      --bg: #07090f; --panel: #0f141d; --card: #121827; --border: #222a38;
      --text: #e8ecf3; --muted: #97a3b6; --accent: #61eaff; --danger: #ff466b;
      --shadow: 0 24px 48px rgba(0,0,0,0.4);
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body {
      margin: 0; color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
      background:
        radial-gradient(1200px 800px at 75% -10%, #0a0f18 10%, var(--bg) 60%),
        linear-gradient(180deg, #080a10 0%, #0c1018 50%, #080a10 100%);
    }
    .topbar {
      position: sticky; top: 0; z-index: 100; display: flex; align-items: center; justify-content: space-between;
      padding: 12px 18px; backdrop-filter: saturate(120%) blur(8px);
      background: rgba(10,12,16,0.65); border-bottom: 1px solid var(--border);
    }
    .brand { display: flex; align-items: center; gap: 10px }
    .logo {
      width: 34px; height: 34px; border-radius: 10px; position: relative;
      border: 1px solid #273247; background: radial-gradient(160px 100px at 30% 20%, #172235, #0f1827 60%);
      box-shadow: inset 0 0 24px rgba(0,212,255,0.18);
    }
    .logo::after { content:""; position:absolute; right:8px; top:8px; width:7px; height:7px; border-radius:50%; background:var(--accent); box-shadow:0 0 12px var(--accent) }
    .status { display:flex; gap:8px; flex-wrap:wrap; color: var(--muted); font-size:12px }
    .pill { padding:5px 10px; border-radius:999px; background:#0e1320; border:1px solid var(--border) }

    .container { max-width: 1100px; margin: 18px auto; padding: 0 18px }
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; overflow: hidden; box-shadow: var(--shadow) }
    .panel-header { padding: 12px 14px; display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid var(--border); background: linear-gradient(180deg,#101522,#0f141d) }

    .videos { display:grid; grid-template-columns: 1fr 1fr; gap:12px; padding:14px }
    @media (max-width: 820px) { .videos { grid-template-columns: 1fr } }
    .video-card {
      position:relative; border-radius:12px; overflow:hidden; background:var(--card); border:1px solid var(--border);
      aspect-ratio: 16/10; box-shadow: inset 0 0 30px rgba(0,0,0,0.35);
    }
    video { width:100%; height:100%; object-fit:cover; background:#000 }
    .label {
      position:absolute; left:10px; bottom:10px; background:rgba(16,20,32,0.72); padding:6px 10px;
      border:1px solid var(--border); border-radius:8px; font-size:12px; color:var(--muted); backdrop-filter: blur(4px);
    }

    .log { padding:12px 14px; font-size:12px; color:var(--muted); height:140px; overflow:auto; border-top:1px solid var(--border); background:#0e121b }
    .controls { display:flex; gap:10px; padding:12px 14px; border-top:1px solid var(--border); background:#0f131d }
    button {
      appearance:none; border:1px solid #2a3242; color:var(--text); background:#121826; padding:10px 14px;
      border-radius:11px; font-weight:600; font-size:14px; transition: transform .16s ease, box-shadow .16s ease, filter .16s ease; cursor:pointer;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,0.25) }
    .danger { background: linear-gradient(180deg,#ff8aa0,#ff466b); border:none; color:#16060a }
    .ghost { background:#131a28; border-color:#2a3242 }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <strong>Random Video — Auto</strong>
    </div>
    <div class="status">
      <span class="pill" id="connStatus">Estado: init</span>
      <span class="pill" id="iceStatus">ICE: —</span>
      <span class="pill" id="peerBadge">Peer: —</span>
      <span class="pill" id="meBadge">UID: —</span>
    </div>
  </div>

  <div class="container">
    <section class="panel">
      <div class="panel-header">
        <span>Videollamada automática uno-a-uno</span>
        <span style="font-size:12px;color:#97a3b6">Abre la página en dos dispositivos/pestañas y conecta solo</span>
      </div>
      <div class="videos">
        <div class="video-card">
          <video id="localVideo" autoplay playsinline muted></video>
          <div class="label">Tú</div>
        </div>
        <div class="video-card">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="label">Random</div>
        </div>
      </div>
      <div class="controls">
        <button class="ghost" id="retryBtn" disabled>Reintentar ICE</button>
        <button class="danger" id="endBtn" disabled>End</button>
      </div>
      <div class="log" id="log"></div>
    </section>
  </div>

  <!-- Firebase v8 compat -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <script>
    // ===== Firebase (tu config) =====
    const firebaseConfig = {
      apiKey: "AIzaSyBWqJI7OKZcEjN2CeTZxPi8pWzo8rBMIkI",
      authDomain: "nearmemarketplace-ce82b.firebaseapp.com",
      projectId: "nearmemarketplace-ce82b",
      storageBucket: "nearmemarketplace-ce82b.firebasestorage.app",
      messagingSenderId: "711845990024",
      appId: "1:711845990024:web:7948ad5e5606765514d93d",
      measurementId: "G-X75JHEDQJ0",
      databaseURL: "https://nearmemarketplace-ce82b-default-rtdb.firebaseio.com"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ===== UI =====
    const logEl = document.getElementById('log');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const connStatus = document.getElementById('connStatus');
    const iceStatus = document.getElementById('iceStatus');
    const peerBadge = document.getElementById('peerBadge');
    const meBadge = document.getElementById('meBadge');
    const retryBtn = document.getElementById('retryBtn');
    const endBtn = document.getElementById('endBtn');

    const log = (msg) => { const ts = new Date().toLocaleTimeString(); logEl.innerHTML = `[${ts}] ${msg}<br>` + logEl.innerHTML; };
    const setConn = (t) => connStatus.textContent = `Estado: ${t}`;
    const setIce = (t) => iceStatus.textContent = `ICE: ${t}`;
    const setPeer = (t) => peerBadge.textContent = `Peer: ${t || '—'}`;
    const setMe = (t) => meBadge.textContent = `UID: ${t || '—'}`;

    // ===== Estado =====
    const me = `u_${Math.random().toString(36).slice(2,10)}`;
    setMe(me);
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let currentPeer = null;
    let listeners = [];
    let presenceUnsub = null;

    // ===== RTDB refs =====
    const presenceRef = db.ref('/presence'); // usuarios presentes
    const offersRef = (from, to) => db.ref(`/signal/${to}/offers/${from}`);
    const answersRef = (from, to) => db.ref(`/signal/${to}/answers/${from}`);
    const candOutRef = (from, to) => db.ref(`/signal/${to}/candidates/${from}`);
    const candInRef = (from, to) => db.ref(`/signal/${to}/candidates/${from}`);

    // ===== WebRTC =====
    const iceServers = [
      { urls: ["stun:stun.l.google.com:19302","stun:stun1.l.google.com:19302"] }
      // Para conexión garantizada entre redes móviles/NAT estrictos añade:
      // { urls: "turn:TU_DOMINIO:3478", username: "USER", credential: "PASS" }
    ];
    const mediaConstraints = { audio: true, video: { width: { ideal: 1280 }, height: { ideal: 720 } } };

    async function initMedia() {
      if (localStream) return localStream;
      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;
        setConn('cam/mic ok');
        return localStream;
      } catch (e) {
        setConn('media error'); log('Error media: ' + e.message); throw e;
      }
    }

    function createPC() {
      pc = new RTCPeerConnection({ iceServers });
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.ontrack = (ev) => {
        ev.streams[0]?.getTracks().forEach(t => remoteStream.addTrack(t));
      };

      pc.onicecandidate = (ev) => {
        if (ev.candidate && currentPeer) {
          candOutRef(me, currentPeer).push(ev.candidate.toJSON());
        }
        if (!ev.candidate) setIce('complete');
      };

      pc.oniceconnectionstatechange = () => {
        const st = pc.iceConnectionState;
        setIce(st);
        if (st === 'connected' || st === 'completed') {
          setConn('conectado');
          endBtn.disabled = false; retryBtn.disabled = false;
        } else if (st === 'failed') {
          setConn('failed'); retryBtn.disabled = false;
        }
      };

      pc.onconnectionstatechange = () => {
        setConn(pc.connectionState);
      };
    }

    function cleanupPC() {
      try {
        if (pc) {
          pc.ontrack = null; pc.onicecandidate = null; pc.oniceconnectionstatechange = null; pc.onconnectionstatechange = null;
          pc.getSenders().forEach(s => { try { pc.removeTrack(s); } catch(e){} });
          pc.close();
        }
      } catch(e) {}
      pc = null;
      if (remoteVideo.srcObject) { remoteVideo.srcObject.getTracks().forEach(t => t.stop()); }
      remoteVideo.srcObject = null;
      setIce('—'); setConn('idle');
    }

    function detachListeners() {
      listeners.forEach(unsub => { try { unsub(); } catch(e){} });
      listeners = [];
    }

    // ===== Señalización (uno a uno) =====
    async function startCallerFlow(peerId) {
      currentPeer = peerId;
      createPC();

      // Escuchar respuesta del peer
      const ansRef = answersRef(peerId, me);
      const ansHandler = ansRef.on('value', async snap => {
        const ans = snap.val();
        if (ans && ans.sdp && pc && !pc.currentRemoteDescription) {
          await pc.setRemoteDescription(new RTCSessionDescription(ans));
          setConn('conectando...');
          log('Respuesta recibida de ' + peerId);
        }
      });
      listeners.push(() => ansRef.off('value', ansHandler));

      // Escuchar ICE remotos
      const candIn = candInRef(peerId, me);
      const candHandler = candIn.on('child_added', async s => {
        const cand = s.val();
        try { await pc.addIceCandidate(new RTCIceCandidate(cand)); } catch(e) { log('ICE add err: ' + e.message); }
      });
      listeners.push(() => candIn.off('child_added', candHandler));

      // Crear y enviar oferta
      const offer = await pc.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 });
      await pc.setLocalDescription(offer);
      await offersRef(me, peerId).set({ sdp: offer.sdp, type: offer.type, ts: Date.now() });
      setIce('gathering');
      setConn('oferta enviada');
      setPeer(peerId);
      log('Oferta enviada a ' + peerId);
    }

    async function startCalleeFlow(peerId) {
      currentPeer = peerId;
      createPC();

      // Escuchar oferta del peer
      const offRef = offersRef(peerId, me);
      const offSnap = await offRef.once('value');
      const offer = offSnap.val();
      if (!offer || !offer.sdp) { log('Oferta no encontrada de ' + peerId); return; }
      await pc.setRemoteDescription(new RTCSessionDescription(offer));

      // Crear y enviar respuesta
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await answersRef(me, peerId).set({ sdp: answer.sdp, type: answer.type, ts: Date.now() });
      setIce('gathering');
      setConn('respuesta enviada');
      setPeer(peerId);
      log('Respuesta enviada a ' + peerId);

      // Escuchar ICE remotos
      const candIn = candInRef(peerId, me);
      const candHandler = candIn.on('child_added', async s => {
        const cand = s.val();
        try { await pc.addIceCandidate(new RTCIceCandidate(cand)); } catch(e) { log('ICE add err: ' + e.message); }
      });
      listeners.push(() => candIn.off('child_added', candHandler));
    }

    async function connectToFirstAvailablePeer() {
      // Obtén todos los presentes excepto yo
      const snap = await presenceRef.once('value');
      const val = snap.val() || {};
      const peers = Object.keys(val).filter(uid => uid !== me);
      const peerId = peers[0];

      if (!peerId) {
        setPeer('—'); log('En espera. No hay peers aún.');
        return;
      }

      // Intenta ser caller; si el otro ya me llamó, entonces seré callee
      const existingOfferToMe = await offersRef(peerId, me).once('value');
      if (existingOfferToMe.val() && existingOfferToMe.val().sdp) {
        await startCalleeFlow(peerId);
      } else {
        await startCallerFlow(peerId);
      }
    }

    // ===== Presence (auto) =====
    async function announcePresence() {
      const myRef = presenceRef.child(me);
      await myRef.set({ uid: me, ts: Date.now() });
      myRef.onDisconnect().remove();

      // Escucha cambios en presencia para auto conectar
      presenceUnsub = presenceRef.on('value', async (snap) => {
        const val = snap.val() || {};
        const peers = Object.keys(val).filter(uid => uid !== me);
        if (!currentPeer && peers.length > 0) {
          // Si no tengo peer, conecto con el primero
          await connectToFirstAvailablePeer();
        }
        // Si mi peer actual desaparece, limpia y busca otro
        if (currentPeer && !peers.includes(currentPeer)) {
          log('Peer salió. Reconectando con otro...');
          await endCall(false);
          await connectToFirstAvailablePeer();
        }
      });
    }

    // ===== Controles =====
    async function endCall(clearSignal = true) {
      detachListeners();
      cleanupPC();
      if (clearSignal && currentPeer) {
        // Limpio mis señales hacia el peer
        await offersRef(me, currentPeer).remove().catch(()=>{});
        await answersRef(me, currentPeer).remove().catch(()=>{});
        await candOutRef(me, currentPeer).remove().catch(()=>{});
        await candInRef(currentPeer, me).remove().catch(()=>{});
      }
      setPeer('—');
      currentPeer = null;
      endBtn.disabled = true; retryBtn.disabled = true;
    }

    async function retryICE() {
      if (!pc || !currentPeer) return;
      try {
        const offer = await pc.createOffer({ iceRestart: true });
        await pc.setLocalDescription(offer);
        await offersRef(me, currentPeer).set({ sdp: offer.sdp, type: offer.type, ts: Date.now(), restart: true });
        setIce('restarting');
        log('ICE restart enviado.');
      } catch (e) {
        log('Fallo ICE restart: ' + e.message);
      }
    }

    // ===== Boot automático =====
    async function boot() {
      setConn('iniciando...');
      try {
        await initMedia();
        // prepara mis rutas de señalización
        await db.ref(`/signal/${me}`).set({ ts: Date.now() }).catch(()=>{});
        db.ref(`/signal/${me}`).onDisconnect().remove();
        // presencia y autoconexión
        await announcePresence();
        // intenta conectar si ya hay alguien
        await connectToFirstAvailablePeer();
      } catch (e) {
        log('Boot error: ' + e.message);
      }
    }

    // Wire UI
    retryBtn.addEventListener('click', retryICE);
    endBtn.addEventListener('click', () => endCall(true));
    document.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>
