<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Video Calls — Auto</title>
  <style>
    :root {
      --bg: #080a10; --panel: #0f1218; --card: #131722; --border: #222836;
      --text: #e8ecf3; --muted: #9aa5b1; --accent: #6df1ff; --accent2: #7cff8b;
      --danger: #ff466b; --warn: #ffb020; --shadow: 0 18px 40px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body {
      margin: 0; color: var(--text);
      background:
        radial-gradient(1200px 800px at 80% -20%, #0b0e14 10%, var(--bg) 60%),
        linear-gradient(160deg, #0a0b10 0%, #0f1218 60%, #0a0b10 100%);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    .topbar {
      position: sticky; top: 0; z-index: 100;
      display: flex; align-items: center; justify-content: space-between;
      padding: 14px 20px; backdrop-filter: saturate(120%) blur(8px);
      background: rgba(10,12,16,0.6); border-bottom: 1px solid var(--border);
    }
    .brand { display: flex; align-items: center; gap: 10px }
    .logo {
      width: 34px; height: 34px; border-radius: 10px;
      background: radial-gradient(180px 120px at 30% 20%, #1a2b3f, #0f1827 60%);
      border: 1px solid #243044; box-shadow: inset 0 0 20px rgba(0,212,255,0.15);
      position: relative;
    }
    .logo::after {
      content: ""; position: absolute; right: 8px; top: 8px; width: 6px; height: 6px; border-radius: 50%;
      background: var(--accent); box-shadow: 0 0 12px var(--accent);
    }
    .brand h1 { margin: 0; font-size: 16px; letter-spacing: .4px }
    .status { display: flex; gap: 8px; flex-wrap: wrap }
    .pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 999px; background: #0e1220; border: 1px solid var(--border);
      color: var(--muted); font-size: 12px;
    }

    .container { max-width: 1200px; margin: 22px auto; padding: 0 22px; display: grid; grid-template-columns: 1.5fr 1fr; gap: 22px }
    @media (max-width: 980px) { .container { grid-template-columns: 1fr } }

    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; overflow: hidden; box-shadow: var(--shadow) }
    .panel-header { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); background: linear-gradient(180deg,#101522,#0f1218) }
    .badge { padding: 6px 10px; border: 1px dashed var(--border); border-radius: 999px; font-size: 12px; color: var(--muted) }

    .videos { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding: 14px }
    @media (max-width: 780px) { .videos { grid-template-columns: 1fr } }
    .video-card { position: relative; border-radius: 12px; overflow: hidden; background: var(--card); border: 1px solid var(--border); aspect-ratio: 16/10; box-shadow: inset 0 0 30px rgba(0,0,0,0.35) }
    video { width: 100%; height: 100%; object-fit: cover; background: #000 }
    .label { position: absolute; left: 10px; bottom: 10px; background: rgba(16,20,32,0.7); padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; font-size: 12px; color: var(--muted); backdrop-filter: blur(4px) }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; padding: 14px; border-top: 1px solid var(--border); background: #0f131d }
    button {
      appearance: none; border: 1px solid #2a3242; color: var(--text);
      background: #121826; padding: 10px 14px; border-radius: 11px; font-weight: 600; font-size: 14px;
      transition: transform .16s ease, box-shadow .16s ease, filter .16s ease; cursor: pointer;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 20px rgba(0,0,0,0.25) }
    .primary { background: linear-gradient(180deg,#6df1ff,#00a8ff); border: none; color: #06121a }
    .danger { background: linear-gradient(180deg,#ff8aa0,#ff466b); border: none; color: #16060a }
    .ghost { background: #131a28; border-color: #2a3242 }
    .warn { background: linear-gradient(180deg,#ffd98b,#ffb020); border: none; color: #2a1e0a }

    .log { padding: 12px 16px; font-size: 12px; color: var(--muted); height: 160px; overflow: auto; border-top: 1px solid var(--border); background: #0e121b }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <h1>Random Video Calls</h1>
    </div>
    <div class="status">
      <span class="pill" id="connStatus">Estado: init</span>
      <span class="pill" id="iceStatus">ICE: —</span>
      <span class="pill" id="matchStatus">Match: —</span>
      <span class="pill" id="roomBadge">Room: —</span>
    </div>
  </div>

  <div class="container">
    <section class="panel">
      <div class="panel-header">
        <strong>Videollamada</strong>
        <span class="badge">Autoconexión + Next infinito</span>
      </div>
      <div class="videos">
        <div class="video-card">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="label">Remote</div>
        </div>
        <div class="video-card">
          <video id="localVideo" autoplay playsinline muted></video>
          <div class="label">Tú</div>
        </div>
      </div>
      <div class="controls">
        <button class="primary" id="nextBtn" disabled>Next</button>
        <button class="ghost" id="muteBtn" disabled>Mute</button>
        <button class="ghost" id="cameraBtn" disabled>Camera off</button>
        <button class="warn" id="retryBtn" disabled>Reintentar</button>
        <button class="danger" id="endBtn" disabled>End</button>
      </div>
      <div class="log" id="log"></div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <strong>Estado</strong>
        <span class="badge">Firebase + WebRTC</span>
      </div>
      <div style="padding: 12px">
        <p class="log" id="tips">
          1) Abre la app en dos pestañas o dispositivos.<br>
          2) Debe conectar solo. Si ves “failed”, tu red puede necesitar TURN.<br>
          3) Next salta al siguiente usuario disponible sin tocar nada más.<br>
        </p>
      </div>
    </section>
  </div>

  <!-- Firebase v8 compat -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <script>
    // ======= Firebase (tu config) =======
    const firebaseConfig = {
      apiKey: "AIzaSyBWqJI7OKZcEjN2CeTZxPi8pWzo8rBMIkI",
      authDomain: "nearmemarketplace-ce82b.firebaseapp.com",
      projectId: "nearmemarketplace-ce82b",
      storageBucket: "nearmemarketplace-ce82b.firebasestorage.app",
      messagingSenderId: "711845990024",
      appId: "1:711845990024:web:7948ad5e5606765514d93d",
      measurementId: "G-X75JHEDQJ0",
      databaseURL: "https://nearmemarketplace-ce82b-default-rtdb.firebaseio.com"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ======= UI =======
    const logEl = document.getElementById('log');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const nextBtn = document.getElementById('nextBtn');
    const muteBtn = document.getElementById('muteBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const retryBtn = document.getElementById('retryBtn');
    const endBtn = document.getElementById('endBtn');
    const connStatus = document.getElementById('connStatus');
    const iceStatus = document.getElementById('iceStatus');
    const matchStatus = document.getElementById('matchStatus');
    const roomBadge = document.getElementById('roomBadge');

    const log = (msg) => {
      const ts = new Date().toLocaleTimeString();
      logEl.innerHTML = `[${ts}] ${msg}<br>` + logEl.innerHTML;
    };
    const setConn = (txt) => connStatus.textContent = `Estado: ${txt}`;
    const setIce = (txt) => iceStatus.textContent = `ICE: ${txt}`;
    const setMatch = (txt) => matchStatus.textContent = `Match: ${txt}`;
    const setRoom = (id) => roomBadge.textContent = `Room: ${id || '—'}`;

    // ======= Estado =======
    const userId = `u_${Math.random().toString(36).slice(2,10)}`;
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let currentRoomId = null;
    let role = null; // 'caller' | 'callee'
    let listeners = [];
    let inviteListener = null;
    let queueNodeRef = null;

    // STUN (para redes estrictas añade TURN)
    const iceServers = [
      { urls: ["stun:stun.l.google.com:19302","stun:stun1.l.google.com:19302"] }
      // { urls: "turn:TU_DOMINIO:3478", username: "USER", credential: "PASS" }
    ];

    const mediaConstraints = { audio: true, video: { width: { ideal: 1280 }, height: { ideal: 720 } } };

    // DB refs
    const queueRef = db.ref('/queue');
    const roomsRef = db.ref('/rooms');
    const invitesRef = db.ref('/invites');

    function cleanupListeners() {
      listeners.forEach(unsub => { try { unsub(); } catch(e){} });
      listeners = [];
      if (inviteListener) { invitesRef.child(userId).off('value', inviteListener); inviteListener = null; }
    }

    async function initMedia() {
      if (localStream) return localStream;
      try {
        localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
        localVideo.srcObject = localStream;
        setConn('cam/mic ok');
        muteBtn.disabled = false; cameraBtn.disabled = false;
        return localStream;
      } catch(e) {
        setConn('media error'); log('Error al obtener media: ' + e.message);
        throw e;
      }
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection({ iceServers });
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.ontrack = (ev) => {
        ev.streams[0]?.getTracks().forEach(t => remoteStream.addTrack(t));
      };

      pc.onicecandidate = (ev) => {
        if (ev.candidate && currentRoomId && role) {
          db.ref(`/rooms/${currentRoomId}/candidates/${role}`).push(ev.candidate.toJSON());
        }
        if (!ev.candidate) setIce('complete');
      };

      pc.oniceconnectionstatechange = () => {
        const st = pc.iceConnectionState;
        setIce(st);
        if (st === 'failed') {
          setConn('failed');
          setMatch('falló');
          retryBtn.disabled = false;
        } else if (st === 'connected' || st === 'completed') {
          setConn('connected');
          setMatch('conectado');
          nextBtn.disabled = false; endBtn.disabled = false; retryBtn.disabled = false;
        }
      };

      pc.onconnectionstatechange = () => {
        setConn(pc.connectionState);
      };

      return pc;
    }

    function listenRemoteCandidates(oppositeRole) {
      const ref = db.ref(`/rooms/${currentRoomId}/candidates/${oppositeRole}`);
      const handler = async snap => {
        const cand = snap.val();
        try { await pc.addIceCandidate(new RTCIceCandidate(cand)); } catch(e) {
          log('addIceCandidate error: ' + e.message);
        }
      };
      ref.on('child_added', handler);
      listeners.push(() => ref.off('child_added', handler));
    }

    // ======= Matchmaking — toma siempre el primero disponible =======
    async function findMatch() {
      // Tomar el primer usuario distinto a mí
      const snap = await queueRef.orderByChild('ts').limitToFirst(20).once('value');
      const val = snap.val();
      const entries = val ? Object.entries(val) : [];

      const candidate = entries.find(([key, data]) => data && data.uid && data.uid !== userId);
      if (!candidate) {
        // No hay: entrar a la cola y esperar invite
        if (!queueNodeRef) {
          queueNodeRef = queueRef.push({ uid: userId, ts: Date.now() });
          queueNodeRef.onDisconnect().remove();
        } else {
          queueNodeRef.set({ uid: userId, ts: Date.now() });
        }
        setMatch('esperando');
        log('En cola. Esperando otro usuario...');
        // Escuchar invites
        inviteListener = invitesRef.child(userId).on('value', async (s) => {
          const invite = s.val();
          if (invite && invite.roomId) {
            await invitesRef.child(userId).remove().catch(()=>{});
            currentRoomId = invite.roomId;
            role = 'callee';
            setRoom(currentRoomId);
            log(`Invite recibido a room ${currentRoomId}.`);
            await startCalleeFlow(currentRoomId);
          }
        });
        return;
      }

      // Emparejar con el candidato
      const [key, data] = candidate;
      await queueRef.child(key).remove().catch(()=>{});
      currentRoomId = `r_${Math.random().toString(36).slice(2,10)}`;
      role = 'caller';
      setRoom(currentRoomId);

      await invitesRef.child(data.uid).set({ roomId: currentRoomId, from: userId, ts: Date.now() });
      log(`Room ${currentRoomId} creada. Invite enviado a ${data.uid}.`);

      await startCallerFlow(currentRoomId);
    }

    // ======= Flujos =======
    async function startCallerFlow(roomId) {
      await initMedia();
      createPeerConnection();
      listenRemoteCandidates('callee');

      const offer = await pc.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 });
      await pc.setLocalDescription(offer);
      await roomsRef.child(roomId).child('offer').set({
        sdp: offer.sdp, type: offer.type, ts: Date.now(), by: userId
      });
      setIce('gathering');
      setConn('oferta enviada');
      log('Oferta enviada. Esperando respuesta...');

      const answerRef = roomsRef.child(roomId).child('answer');
      const handler = async snap => {
        const ans = snap.val();
        if (ans && ans.sdp && pc && !pc.remoteDescription) {
          await pc.setRemoteDescription(new RTCSessionDescription(ans));
          setConn('conectando...');
          log('Respuesta recibida. Conectando...');
        }
      };
      answerRef.on('value', handler);
      listeners.push(() => answerRef.off('value', handler));

      nextBtn.disabled = false; endBtn.disabled = false; retryBtn.disabled = false;
    }

    async function startCalleeFlow(roomId) {
      await initMedia();
      createPeerConnection();
      listenRemoteCandidates('caller');

      const offerSnap = await roomsRef.child(roomId).child('offer').once('value');
      const offer = offerSnap.val();
      if (!offer || !offer.sdp) {
        log('Error: oferta no encontrada.');
        return endCall(true);
      }
      await pc.setRemoteDescription(new RTCSessionDescription(offer));

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await roomsRef.child(roomId).child('answer').set({
        sdp: answer.sdp, type: answer.type, ts: Date.now(), by: userId
      });
      setIce('gathering');
      setConn('respuesta enviada');
      log('Respuesta enviada. Conectando...');

      nextBtn.disabled = false; endBtn.disabled = false; retryBtn.disabled = false;
    }

    // ======= Controles =======
    async function next() {
      log('Next: saltando al siguiente usuario.');
      await endCall(false);
      // Asegura que vuelvo a la cola si no encuentro a nadie
      await ensureInQueue();
      await findMatch();
    }

    async function ensureInQueue() {
      if (!queueNodeRef) {
        queueNodeRef = queueRef.push({ uid: userId, ts: Date.now() });
        queueNodeRef.onDisconnect().remove();
      } else {
        await queueNodeRef.set({ uid: userId, ts: Date.now() });
      }
    }

    function toggleMute() {
      const enabled = localStream.getAudioTracks().some(t => t.enabled);
      localStream.getAudioTracks().forEach(t => t.enabled = !enabled);
      muteBtn.textContent = enabled ? 'Unmute' : 'Mute';
    }

    function toggleCamera() {
      const enabled = localStream.getVideoTracks().some(t => t.enabled);
      localStream.getVideoTracks().forEach(t => t.enabled = !enabled);
      cameraBtn.textContent = enabled ? 'Camera on' : 'Camera off';
    }

    async function retry() {
      if (!pc || !currentRoomId) { log('Nada que reintentar.'); return; }
      try {
        const offer = await pc.createOffer({ iceRestart: true });
        await pc.setLocalDescription(offer);
        await roomsRef.child(currentRoomId).child('offer').set({
          sdp: offer.sdp, type: offer.type, ts: Date.now(), by: userId, restart: true
        });
        setIce('restarting');
        log('ICE restart enviado.');
      } catch (e) {
        log('Fallo al reintentar: ' + e.message);
      }
    }

    async function endCall(clearRoom = true) {
      cleanupListeners();

      try {
        if (pc) {
          pc.ontrack = null;
          pc.onicecandidate = null;
          pc.oniceconnectionstatechange = null;
          pc.onconnectionstatechange = null;
          pc.getSenders().forEach(s => { try { pc.removeTrack(s); } catch(e){} });
          pc.close();
        }
      } catch(e) {}
      pc = null;

      if (remoteVideo.srcObject) { remoteVideo.srcObject.getTracks().forEach(t => t.stop()); }
      remoteVideo.srcObject = null;

      if (currentRoomId && clearRoom) {
        try { await roomsRef.child(currentRoomId).remove(); } catch(e) {}
      }
      currentRoomId = null;
      role = null;
      setRoom(null);
      setMatch('—');
      setConn('idle');
      setIce('—');

      nextBtn.disabled = true; endBtn.disabled = true; retryBtn.disabled = true;
    }

    // ======= Auto-inicio =======
    async function boot() {
      setConn('iniciando...');
      try {
        await initMedia();
        await ensureInQueue();
        // Intento inmediato de match; si no hay, quedo escuchando invites
        await findMatch();
      } catch (e) {
        log('Error al iniciar: ' + e.message);
      }
    }

    // ======= Wire UI =======
    nextBtn.addEventListener('click', next);
    endBtn.addEventListener('click', () => endCall(true));
    muteBtn.addEventListener('click', toggleMute);
    cameraBtn.addEventListener('click', toggleCamera);
    retryBtn.addEventListener('click', retry);

    // Autostart al cargar
    document.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>
